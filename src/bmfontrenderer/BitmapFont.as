package bmfontrenderer {
import flash.display.BitmapData;
import flash.geom.Matrix;
import flash.geom.Point;
import flash.geom.Rectangle;
import flash.utils.Dictionary;

/**
 * Represents a bitmapped font which can be drawn to a BitmapData.
 *
 * Uses BMFont data as generated by :
 *  - BMFont (http://www.angelcode.com/products/bmfont/, win32)
 *  - Hiero (http://slick.cokeandcode.com/demos/hiero.jnlp, cross platform)
 *  - Littera (http://kvazars.com/littera/, web)
 *
 * Currently does not support:
 *      - Kerning.
 *      - Channel packing (currently blits all channels).
 *      - Line breaks/text alignment.
 *      - Unicode outside of the Basic Multilingual Plane.
 */
public class BitmapFont {

	private static var glyphMap:Dictionary = new Dictionary();
	private static var glyphLineHeight:Dictionary = new Dictionary();
	private static var sheets:Dictionary = new Dictionary();

	private static var defaultFont:String;

	private static var newLineNChar:int;
	private static var newLineRChar:int;


	//---------------------------------
	//
	//---------------------------------

	public static function createText(text:String, fontName:String = null, startX:int = 0, startY:int = 0, textAlign:String = "left"):BitmapData {
		var retVal:BitmapData;
		var blockVo:BitmapBlockVO = getTextSize(fontName, text);
		if (blockVo.width && blockVo.height) {
			retVal = new BitmapData(startX + blockVo.width, startY + blockVo.height, true, 0xFF);
			drawString(text, retVal, fontName, startX, startY, textAlign);
		} else {
			retVal = new BitmapData(1, 1, true, 0xFF);
		}
		return retVal;
	}


	/**
	 * Draw a string to a BitmapData.
	 *
	 * @param text String to draw.
	 * @param target BitmapData to draw to.
	 * @param startX X pixel position to start drawing at.
	 * @param startY Y pixel position to start drawing at.
	 *
	 */
	public static function drawString(text:String, target:BitmapData, fontName:String = null, startX:int = 0, startY:int = 0, textAlign:String = "left"):void {
		if (!fontName) {
			fontName = defaultFont;
		}
		var blockVo:BitmapBlockVO = getTextSize(fontName, text);
		var fontMap:Array = glyphMap[fontName];
		var fontPics:Array = sheets[fontName];
		if (fontMap && fontPics) {
			var lineNr:int = 0;
			var curX:int = startX;
			var curY:int = startY;
			if (blockVo.lineWidth.length > lineNr) {
				if (textAlign == BitmapTextAlign.CENTER) {
					curX += blockVo.width / 2 - blockVo.lineWidth[lineNr] / 2;
				}
				if (textAlign == BitmapTextAlign.RIGHT) {
					curX += blockVo.width - blockVo.lineWidth[lineNr];
				}
			}
			var sourceRectangle:Rectangle = new Rectangle();
			var destinationPoint:Point = new Point();
			// Walk the string.
			for (var curCharIdx:int = 0; curCharIdx < text.length; curCharIdx++) {
				// Identify the glyph.
				var curChar:int = text.charCodeAt(curCharIdx);
				if (curChar == newLineNChar || curChar == newLineRChar) {
					// skip double new line chars.
					if (curChar == newLineNChar && curCharIdx < text.length - 1) {
						curChar = text.charCodeAt(curCharIdx + 1);
						if (curChar == newLineRChar) {
							curCharIdx += 1;
						}
					}
					if (curChar == newLineRChar && curCharIdx < text.length - 1) {
						curChar = text.charCodeAt(curCharIdx + 1);
						if (curChar == newLineNChar) {
							curCharIdx += 1;
						}
					}
					curX = startX;
					curY += glyphLineHeight[fontName];
					lineNr++;
					if (blockVo.lineWidth.length > lineNr) {
						if (textAlign == BitmapTextAlign.CENTER) {
							curX += blockVo.width / 2 - blockVo.lineWidth[lineNr] / 2;
						}
						if (textAlign == BitmapTextAlign.RIGHT) {
							curX += blockVo.width - blockVo.lineWidth[lineNr];
						}
					}
				} else {
					var curGlyph:BitmapGlyph = fontMap[curChar];
					if (curGlyph) {
						var sourceBd:BitmapData = fontPics[curGlyph.page];
						// skip missing glyphs.
						if (sourceBd) {
							// set draw parameters
							sourceRectangle.x = curGlyph.x;
							sourceRectangle.y = curGlyph.y;
							sourceRectangle.width = curGlyph.width;
							sourceRectangle.height = curGlyph.height;
							destinationPoint.x = curX + curGlyph.xoffset;
							destinationPoint.y = curY + curGlyph.yoffset;
							// Draw the glyph.
							target.copyPixels(sourceBd, sourceRectangle, destinationPoint, null, null, true);
							// Update cursor position
							curX += curGlyph.xadvance;
						}
					}
				}
			}
		}
	}

	public static function getTextSize(fontName:String, text:String):BitmapBlockVO {
		var retVal:BitmapBlockVO = new BitmapBlockVO();
		if (!fontName) {
			fontName = defaultFont;
		}
		var fontMap:Array = glyphMap[fontName];
		var fontPics:Array = sheets[fontName];
		if (fontMap && fontPics) {
			var curX:int = 0;
			var curY:int = 0;
			var nextX:int = 0;
			var nextY:int = 0;
			// Walk the string.
			for (var curCharIdx:int = 0; curCharIdx < text.length; curCharIdx++) {
				// Identify the glyph.
				var curChar:int = text.charCodeAt(curCharIdx);
				if (curChar == newLineNChar || curChar == newLineRChar) {
					// skip double new line chars.
					if (curChar == newLineNChar && curCharIdx < text.length - 1) {
						curChar = text.charCodeAt(curCharIdx + 1);
						if (curChar == newLineRChar) {
							curCharIdx += 1;
						}
					}
					if (curChar == newLineRChar && curCharIdx < text.length - 1) {
						curChar = text.charCodeAt(curCharIdx + 1);
						if (curChar == newLineNChar) {
							curCharIdx += 1;
						}
					}
					retVal.lineWidth.push(nextX);
					curX = 0;
					curY += glyphLineHeight[fontName];
				} else {
					var curGlyph:BitmapGlyph = fontMap[curChar];
					if (curGlyph) {
						var sourceBd:BitmapData = fontPics[curGlyph.page];
						// skip missing glyphs.
						if (sourceBd) {
							nextX = curX + curGlyph.xoffset + curGlyph.width;
							nextY = curY + curGlyph.yoffset + curGlyph.height;
							curX += curGlyph.xadvance;

							if (retVal.width < nextX) {
								retVal.width = nextX;
							}
							if (retVal.height < nextY) {
								retVal.height = nextY;
							}
							// Update cursor position
						}
					}
				}
			}
		}
		retVal.lineWidth.push(nextX);
		return retVal;
	}

	//---------------------------------
	// set up
	//---------------------------------

	public static function addFont(fontName:String, fontDesc:String, pagePics:Array, isFlipped:Boolean = false, useAsDefault:Boolean = false):void {
		parseFont(fontName, fontDesc);
		for (var i:int = 0; i < pagePics.length; i++) {
			var pageBD:BitmapData = pagePics[i];
			addSheet(fontName, i, pageBD, isFlipped);
		}
		if (useAsDefault || !defaultFont) {
			defaultFont = fontName;
		}
		newLineNChar = String("\n").charCodeAt(0);
		newLineRChar = String("\r").charCodeAt(0);
	}

	/**
	 * Add a bitmap sheet.
	 */
	private static function addSheet(fontName:String, id:int, bits:BitmapData, isFlipped:Boolean = false):void {
		if (!sheets[fontName]) {
			sheets[fontName] = new Array();
		}
		if (sheets[fontName][id] != null) {
			throw new Error("Overwriting sheet!");
		}
		if (isFlipped) {
			sheets[fontName][id] = flipVert(bits);
		} else {
			sheets[fontName][id] = bits;
		}
	}

	/**
	 * Parse a BMFont textual font description.
	 */
	private static function parseFont(fontName:String, fontDesc:String):void {
		if (!glyphMap[fontName]) {
			glyphMap[fontName] = new Array();
		}
		var fontLines:Array = fontDesc.split("\n");
		for (var i:int = 0; i < fontLines.length; i++) {
			// Lines can be one of:  info,  page,  chars,  char,  common
			var fontLine:Array = (fontLines[i] as String).split(" ");
			var keyWord:String = (fontLine[0] as String).toLowerCase();
			if (keyWord == "char") {
				parseChar(fontName, fontLine);
			} else if (keyWord == "common") {
				parseLineHeight(fontName, fontLine);
			}
		}
	}

	/**
	 * Helper function to parse and register a glyph from a BMFont
	 * description..
	 */
	private static function parseChar(fontName:String, charLine:Array):void {
		var g:BitmapGlyph = new BitmapGlyph();
		for (var i:int = 1; i < charLine.length; i++) {
			// Parse to key value.
			var charEntry:Array = (charLine[i] as String).split("=");
			if (charEntry.length == 2) {
				var charKey:String = charEntry[0];
				var charVal:String = charEntry[1];

				// Assign to glyph.
				if (g.hasOwnProperty(charKey)) {
					g[charKey] = charVal;
				}
			}
		}
		glyphMap[fontName][g.id] = g;
	}

	private static function parseLineHeight(fontName:String, commonLine:Array):void {
		glyphLineHeight[fontName] = 0;
		for (var i:int = 1; i < commonLine.length; i++) {
			// Parse to key value.
			var charEntry:Array = (commonLine[i] as String).split("=");
			if (charEntry.length == 2) {
				var charKey:String = charEntry[0];
				if (charKey == "lineHeight") {
					glyphLineHeight[fontName] = int(charEntry[1]);
				}
			}
		}
	}


	//---------------------------------
	// utils
	//---------------------------------

	/**
	 * Utility function to return a copy of a BitmapData flipped vertically.
	 */
	public static function flipVert(bd:BitmapData):BitmapData {
		var mat:Matrix = new Matrix();
		mat.d = -1;
		mat.ty = bd.height;
		var flip:BitmapData = new BitmapData(bd.width, bd.height, bd.transparent, 0x0);
		flip.draw(bd, mat);
		return flip;
	}


}
}